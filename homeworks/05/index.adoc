= Homework for the 6th practice

== Topics of the current practice

++++
<style>li details { margin-bottom: 0.5em; }</style>
<div class='olist arabic'>
<ol class='arabic'>
<li><details><summary>In the home directory, create a subdirectory <code>scripts</code> and then create a script named <code>output</code> in that subdirectory. The script should print 5 lines (numbers from 1 to 5) to standard output and 3 lines (letters a, b, c) to standard error output.</summary>
++++
....
mkdir ~/scripts
gedit ~/scripts/output   # instead of gedit you can use another editor (vim, nano, ...)

#!/bin/bash
printf '%s\n' {1..5}
printf '%s\n' {a..c} >&2
....
++++
</details></li>
<li><details><summary>Use the command: <code>chmod +x <em>file</em></code>to add executable rights to the file and run the script.</summary>
++++
....
chmod +x ~/scripts/output
~/scripts/output
....
++++
</details></li>
<li><details><summary>Make the necessary settings so that the script can only be run by name without a path and run it.</summary>
++++
....
#1
alias output=~/scripts/output
output

#2
PATH=$PATH:~/scripts
output
....
++++
</details></li>
<li><details><summary>Join and save the standard output and standard error output of the script <code>output</code> to a file <code>all</code> in the home directory, and write the number of lines of the script output to the terminal.</summary>
++++
....
output 2>&1 | tee ~/all | wc -l
....
++++
</details></li>
<li><details><summary>Add the standard output of the script <code>output</code> to the file <code>all</code>, discard the standard error output, and write the number of lines added to the file to the terminal.</summary>
++++
....
output 2>/dev/null | tee -a ~/all | wc -l
....
++++
</details></li>
<li><details><summary>Add the standard error output of the script<code>output</code> to the file <code>all</code>, discard the standard output, and write the number of lines added to the file to the terminal.</summary>
++++
....
output 2>&1 >/dev/null | tee -a ~/all | wc -l
....
++++
</details></li>
<li><details><summary>Divide the file <code>all</code> into halves and save those halves to files  <code>s1</code> and <code>s2</code>. <em>On Solaris, use the GNU commands form the directory <code>/usr/gnu/bin</code>.</em></summary>
++++
....
lines=$(wc -l <~/all)
((lines=lines/2))

#1
head -n "$lines" all > s1
tail -n "$lines" all > s2

#2
split -a 1 --numeric-suffixes=1 -l "$lines" all s

....
++++
</details></li>
<li><details><summary>Compare whether the files  <code>s1</code> and <code>s2</code> are the same and, if so, write: <code>files are the same</code> .</summary>
++++
....
cmp s1 s2 && echo "files are the same"
....
++++
</details></li>
<li><details><summary>Use the standard output of the command <code>getent passwd</code> on the computer <code>fray1</code> Write out only the 5th column (the user name) and save the result in a file <code>jmena</code> .</summary>
++++
....
getent passwd | cut -d: -f5 >jmena
....
++++
</details></li>
<li><details><summary>If the file <code>jmena</code> has at least 10000 lines, write: <code>File 'jmena' OK</code> .</summary>
++++
....
(( $(wc -l <jmena) >= 10000 )) && echo "File 'jmena' OK"
....
++++
</details></li>
<li><details><summary>File <code>jmena</code> contains blank (empty) lines, use commands <code>sort</code> and <code>tail</code> to delete them.</summary>
++++
....
sort jmena | cat -n | head

#1
sort jmena | tail -n +7 >jmena2; mv jmena{2,}

#2
grep '^$' jmena >jmena2; mv jmena{2,}
....
++++
</details></li>
<li><details><summary>Use commands <code>grep ' student$' <em>file</em></code> and <code>grep ' zam$' <em>file</em></code> to create files <code>jmena.stu</code> and <code>jmena.zam</code> containing only names of students or names of employees respectively.</summary>
++++
....
grep ' student$' jmena >jmena.stu
grep ' zam$' jmena >jmena.zam
....
++++
</details></li>
<li><details><summary>Use the (GNU version) of command wc to determine which file has the longest line. Save the name of such a file in the LONG variable. If there is a match, select any file.</summary>
++++
....
S=$(/usr/gnu/bin/wc -L <jmena.stu)
Z=$(/usr/gnu/bin/wc -L <jmena.zam)
LONG=jmena.zam
((S>Z)) && LONG=jmena.stu
....
++++
</details></li>
<li><details><summary>Write the longest line of the file from the variable <code>LONG</code>. The solution using simple filters is complicated, more advanced filters (discussed later) will simplify the solution considerably.<ol>
<li>Replace all characters except the new line with any character (such as a period) in the file.</li>
<li>Number the output lines.</li>
<li>Sort the output alphabetically so that the longest line is the first (be aware of the line number).</li>
<li>List only the first line.</li>
<li>List only the first column, ie the line number, from this line. The line number is separated from the rest by a tab.</li>
<li>Save this number in a variable <code>L</code> .</li>
<li>From a file in a variable <code>LONG</code> list a line numbe <code>L</code> .</li>
<li>Calculate the number of name words on this line (watch out for the student/zam).</li>
</ol></summary>
++++
....
#1
tr -c '\n' '[.*]' <"$LONG"
/usr/gnu/bin/tr -c '\n' . <"$LONG"

#2
tr -c '\n' '[.*]' <"$LONG" | cat -n

#3
tr -c '\n' '[.*]' <"$LONG" | cat -n | sort -k 2,2r

#4
tr -c '\n' '[.*]' <"$LONG" | cat -n | sort -k 2,2r | head -n 1

#5
tr -c '\n' '[.*]' <"$LONG" | cat -n | sort -k 2,2r | head -n 1 | cut -f1

#6
L=$(tr -c '\n' '[.*]' <"$LONG" | cat -n | sort -k 2,2r | head -n 1 | cut -f1)

#7
head -n "$L" "$LONG" | tail -1

#8
echo $(( $(head -n "$L" "$LONG" | tail -1 | wc -w) - 1 ))
....
++++
</details></li>
<li><details><summary>Does the end of the previous example mean that we found the name consisting of the most words?</summary>
++++
....
# No, the longest line does not necessarily contain the most words.
# For impatient, the concept of line lengths and the number of words in a name:
awk 'NF>=max { max=NF; print NF-1,length,$0 }' jmena.zam jmena.stu
....
++++
</details></li>
<li><details><summary>Use the command <code>awk 'NF==3' <em>file</em></code> to leave only lines in files <code>jmena.stu</code> and <code>jmena.zam</code> that contain only one first and one last name.</summary>
++++
....
awk 'NF==3' jmena.stu >jmena.stu2; mv jmena.stu{2,}
awk 'NF==3' jmena.zam >jmena.zam2; mv jmena.zam{2,}
....
++++
</details></li>
<li><details><summary>Join files <code>jmena.zam</code> and <code>jmena.stu</code> back into one file <code>jmena</code> .</summary>
++++
....
cat jmena.{zam,stu} >jmena
....
++++
</details></li>
<li><details><summary>Use the command  <code>grep -v 'docasne konto' <em>soubor</em></code> to remove the rows of temporary student accounts from the file <code>jmena</code> .</summary>
++++
....
grep -v 'docasne konto' jmena >jmena2; mv jmena{2,}
....
++++
</details></li>
<li><details><summary>Verify that size of the file  <code>jmena</code> is the exact sum of sizes of files <code>jmena.zam</code> and <code>jmena.stu</code> . If not, write the following text to the standard output: <code>Join failed!</code> </summary>
++++
....
J=$(wc -c <jmena)
S=$(wc -c <jmena.stu)
Z=$(wc -c <jmena.zam)
((J==S+Z)) || echo 'Join failed!'
....
++++
</details></li>
<li><details><summary>Save only last names and names from file  <code>jmena</code> in file <code>jmena2</code>.</summary>
++++
....
cut -d' ' -f1 jmena > j
cut -d' ' -f2 jmena > p
paste -d' ' p j > jmena2
....
++++
</details></li>
<li><details><summary>Write names, that represent both first and last names, from the file <code>jmena2</code> to the standard error output,  and  at the same time the number of these names write to the standard output. You can use a special file <code>/dev/stderr</code> to print out the error output.</summary>
++++
....
cut -d' ' -f1 jmena2 | sort -u > p
cut -d' ' -f2 jmena2 | sort -u > j
comm -12 j p | tee /dev/stderr | wc -l
....
++++
</details></li>
<li><details><summary>List the most common first and last names separated by a colon from the file<code>jmena2</code>  The lists will be internally separated by a comma. So the output will be <code>fn1,fn2,fn3,fn4,fn:ln1,ln2,ln3,ln4,ln5</code> .</summary>
++++
....
P=$(cut -d' ' -f1 jmena2 | sort | uniq -c | sort -n -k1,1r | head -n 5 | tr -s ' ' | cut -d' ' -f3 | paste -d, -s -)
J=$(cut -d' ' -f2 jmena2 | sort | uniq -c | sort -n -k1,1r | head -n 5 | tr -s ' ' | cut -d' ' -f3 | paste -d, -s -)
printf '%s:%s\n' "$J" "$P"
....
++++
</details></li>
</ol>
</div>
++++ 


== Topics of the next practice

++++
<div class='olist arabic'>
<ol class='arabic'>
<li><details><summary>Create a file <code>morse</code> containing Morse code - use the following solution.</summary>
++++
....
cat <<END >morse
a . −
i . .
r . − .
b − . . .
j . − − −
s . . .
c − . − .
k − . −
t −
d − . .
l . − . .
u . . −
e .
m − −
v . . . −
n − .
w . − −
f . . − .
o − − −
x − . . −
g − − .
p . − − .
y − . − −
h . . . .
q − − . −
z − − . .
END
....
++++
</details></li>
<li><details><summary>Sort the file <code>morse</code> alphabetically.</summary>
++++
....
sort morse
....
++++
</details></li>
<li><details><summary>Use a loop <code>for</code> to add a row length to the beginning of each row in file <code>morse</code>.</summary>
++++
....
IFS=$'\n'
for line in $(< morse)
do
	printf '%d %s\n' ${#line} "$line"
done >morse.new
mv morse{.new,}
....
++++
</details></li>
<li><details><summary> Sort the Morse code from the file <code>morse</code> according to the length of the code of each character, where for the same length the dot is shorter than the dash. Remove the character length from the output.</summary>
++++
....
sort -k1,1n -k3 morse | cut -d' ' -f2-
....
++++
</details></li>
<li><details><summary>From the ordered Morse code from the previous example, write only individual letters on one line immediately after each other.</summary>
++++
....
sort -k1,1n -k3 morse | cut -d' ' -f2 | paste -s -d ''

# or

sort -k1,1n -k3 morse | cut -d' ' -f2 | tr -d '\n'; echo
....
++++
</details></li>
<li><details><summary>In the manual page of command <code> bash </code>, convert uppercase letters to lowercase and list them by frequency of occurrence of each letter in the text. Perform the output in the same format as the previous example.<ol>
	<li>List the  command page of command bash,</li>
	<li>delete all characters except the letters,</li>
	<li>convert capital letters to lowercase,</li>
	<li>wrap the text to the width of one character,</li>
	<li>sort the characters alphabetically,</li>
	<li>calculate the frequency of each character,</li>
	<li>sort by frequency,</li>
	<li>remove all characters except lowercase characters from the output,</li>
	<li>add a new line to the end of the listing.</li>
</ol></summary>
++++
....
#1
man bash

#2
man bash | tr -dc a-zA-Z

#3
man bash | tr -dc a-zA-Z | tr A-Z a-z

#4
man bash | tr -dc a-zA-Z | tr A-Z a-z | fold -w1

#5
man bash | tr -dc a-zA-Z | tr A-Z a-z | fold -w1 | sort

#6
man bash | tr -dc a-zA-Z | tr A-Z a-z | fold -w1 | sort | uniq -c

#7
man bash | tr -dc a-zA-Z | tr A-Z a-z | fold -w1 | sort | uniq -c | sort -nr

#8
man bash | tr -dc a-zA-Z | tr A-Z a-z | fold -w1 | sort | uniq -c | sort -nr | tr -dc a-z

#9
man bash | tr -dc a-zA-Z | tr A-Z a-z | fold -w1 | sort | uniq -c | sort -nr | tr -dc a-z; echo
....
++++
</details></li>
++++
++++
</ol>
</div>
++++ 
